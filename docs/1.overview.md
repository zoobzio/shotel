---
title: Overview
description: Config-driven capitan-to-OTEL bridge for Go applications
author: zoobzio
published: 2025-12-11
updated: 2025-12-11
tags:
  - Overview
  - Introduction
---

# Overview

Connecting application events to observability platforms usually means manual instrumentation scattered throughout your code.

Aperture offers a declarative alternative: configure how capitan events become OpenTelemetry signals, and the bridge handles the rest.

```go
// Define signals and keys
orderCreated := capitan.NewSignal("order.created", "Order created")
orderID := capitan.NewStringKey("order_id")

// Configure the bridge
config := &aperture.Config{
    Metrics: []aperture.MetricConfig{
        {Signal: orderCreated, Name: "orders_created_total", Type: aperture.MetricTypeCounter},
    },
}

// Create aperture with your OTEL providers
ap, _ := aperture.New(cap, logProvider, meterProvider, traceProvider, config)
defer ap.Close()

// Events automatically become OTEL signals
cap.Emit(ctx, orderCreated, orderID.Field("ORDER-123"))
// ^ Logged to OTEL + counter incremented
```

Type-safe, config-driven, explicit provider configuration.

## Architecture

```
┌─────────────────────────────────────────────────────────────┐
│                         Aperture                            │
│                                                             │
│  ┌─────────────────────────────────────────────────────┐   │
│  │                   Observer                           │   │
│  │         (receives all capitan events)               │   │
│  └─────────────────────────────────────────────────────┘   │
│                           │                                 │
│           ┌───────────────┼───────────────┐                 │
│           ▼               ▼               ▼                 │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐           │
│  │   Logger    │ │   Metrics   │ │   Traces    │           │
│  │  Transform  │ │  Transform  │ │  Transform  │           │
│  └─────────────┘ └─────────────┘ └─────────────┘           │
│           │               │               │                 │
│           ▼               ▼               ▼                 │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐           │
│  │    OTEL     │ │    OTEL     │ │    OTEL     │           │
│  │  LogProvider│ │MeterProvider│ │TraceProvider│           │
│  └─────────────┘ └─────────────┘ └─────────────┘           │
└─────────────────────────────────────────────────────────────┘
```

Aperture registers as a capitan observer, receives all events, and transforms them according to configuration. You provide pre-configured OTEL providers; aperture handles the event-to-signal mapping.

## Philosophy

Aperture draws a clear line: **opinionated about event transformation, agnostic about provider configuration**.

What aperture decides:
- How capitan fields become OTEL attributes
- How signal pairs correlate into spans
- How events filter to logs

What you decide:
- Which exporters to use (OTLP, stdout, custom)
- How to batch and buffer
- Security, sampling, resource attributes

```go
// Your configuration choices
logProvider := log.NewLoggerProvider(
    log.WithResource(myResource),
    log.WithProcessor(log.NewBatchProcessor(myExporter)),
)

// Aperture's transformation rules
config := &aperture.Config{
    Metrics: []aperture.MetricConfig{...},
    Traces:  []aperture.TraceConfig{...},
    Logs:    &aperture.LogConfig{...},
}

// Two concerns, cleanly separated
ap, _ := aperture.New(cap, logProvider, meterProvider, traceProvider, config)
```

## Capabilities

Configuration drives behavior:

**[Metrics](3.guides/1.metrics.md)** - Count events, record values, track distributions. Signal emissions become counter increments, gauge updates, or histogram observations.

**[Traces](3.guides/2.traces.md)** - Correlate signal pairs into spans. `request.started` and `request.completed` with matching request IDs create a single span.

**[Logs](3.guides/3.logs.md)** - Filter events to logs. Whitelist specific signals or log everything.

**[Context](3.guides/4.context.md)** - Extract values from `context.Context` and add them as attributes to all three signal types.

**[Schema](3.guides/5.schema.md)** - Load configuration from YAML/JSON files with hot-reload support.

## Priorities

### Explicit Configuration

No magic defaults that might expose data unexpectedly. You construct providers explicitly, you configure transformations explicitly.

```go
// You control the exporter
exporter, _ := otlptracehttp.New(ctx, otlptracehttp.WithEndpoint("localhost:4318"))

// You control the provider
traceProvider := trace.NewTracerProvider(
    trace.WithSpanProcessor(trace.NewBatchSpanProcessor(exporter)),
    trace.WithSampler(trace.TraceIDRatioBased(0.1)),
)

// You pass it to aperture
ap, _ := aperture.New(cap, logProvider, meterProvider, traceProvider, config)
```

### Type Safety

Field transformation preserves types. Custom types get custom transformers.

```go
type OrderInfo struct {
    ID     string
    Total  float64
    Secret string // Not exported
}

config := &aperture.Config{
    Transformers: map[capitan.Variant]aperture.FieldTransformer{
        orderVariant: aperture.MakeTransformer(func(key string, order OrderInfo) []log.KeyValue {
            return []log.KeyValue{
                log.String(key+".id", order.ID),
                log.Float64(key+".total", order.Total),
                // Secret intentionally omitted
            }
        }),
    },
}
```

### OTEL Native

Aperture exposes standard OTEL interfaces. Use them directly when you need to:

```go
logger := ap.Logger("orders")
meter := ap.Meter("orders")
tracer := ap.Tracer("orders")

// Standard OTEL usage
ctx, span := tracer.Start(ctx, "process-order")
defer span.End()
```

The bridge adds automatic event transformation; it doesn't replace direct OTEL usage.
