---
title: Context Extraction
description: Enrich signals with context values
author: zoobzio
published: 2025-12-11
updated: 2025-12-11
tags:
  - Guide
  - Context
---

# Context Extraction Guide

Extract values from `context.Context` and add them as attributes to logs, metrics, and traces.

## Configuration

Specify which context keys to extract for each signal type:

```go
type ctxKey string
const (
    userIDKey    ctxKey = "user_id"
    regionKey    ctxKey = "region"
    requestIDKey ctxKey = "request_id"
)

config := &aperture.Config{
    ContextExtraction: &aperture.ContextExtractionConfig{
        Logs: []aperture.ContextKey{
            {Key: userIDKey, Name: "user_id"},
            {Key: requestIDKey, Name: "request_id"},
        },
        Metrics: []aperture.ContextKey{
            {Key: regionKey, Name: "region"},  // Low cardinality only
        },
        Traces: []aperture.ContextKey{
            {Key: userIDKey, Name: "user_id"},
            {Key: regionKey, Name: "region"},
        },
    },
}
```

## Usage

Add values to context, then emit events:

```go
ctx := context.Background()
ctx = context.WithValue(ctx, userIDKey, "user-123")
ctx = context.WithValue(ctx, regionKey, "us-east-1")
ctx = context.WithValue(ctx, requestIDKey, "req-456")

cap.Emit(ctx, orderCreated, orderID.Field("ORD-789"))
```

Results:
- Log: `user_id="user-123"`, `request_id="req-456"`, `order_id="ORD-789"`
- Metric: `region="us-east-1"` dimension
- Trace span: `user_id="user-123"`, `region="us-east-1"` attributes

## Supported Value Types

Context values are converted to attributes:

| Go Type | OTEL Attribute |
|---------|----------------|
| `string` | String |
| `int`, `int32`, `int64` | Int64 |
| `uint`, `uint32`, `uint64` | Int64 |
| `float32`, `float64` | Float64 |
| `bool` | Bool |
| `[]byte` | Bytes |

Other types are skipped silently.

## Missing Values

If a context key is configured but not present:
- The attribute is simply not added
- No error or warning
- Other attributes still extracted

```go
config := &aperture.Config{
    ContextExtraction: &aperture.ContextExtractionConfig{
        Logs: []aperture.ContextKey{
            {Key: userIDKey, Name: "user_id"},
            {Key: sessionKey, Name: "session_id"},
        },
    },
}

// Only user_id set
ctx = context.WithValue(ctx, userIDKey, "user-123")

cap.Emit(ctx, sig)
// Log includes user_id="user-123"
// session_id not present, not added
```

## Cardinality Warning for Metrics

Metric dimensions multiply storage:

```go
// GOOD for metrics: bounded, low cardinality
regionKey    // ~10-20 values
tierKey      // ~3 values
environmentKey // ~3 values

// BAD for metrics: unbounded, high cardinality
userIDKey    // ~millions of values
requestIDKey // ~infinite values
sessionKey   // ~millions of values
```

Separate extraction configs let you be selective:

```go
config := &aperture.Config{
    ContextExtraction: &aperture.ContextExtractionConfig{
        // High cardinality OK for logs and traces
        Logs: []aperture.ContextKey{
            {Key: userIDKey, Name: "user_id"},
            {Key: requestIDKey, Name: "request_id"},
        },
        Traces: []aperture.ContextKey{
            {Key: userIDKey, Name: "user_id"},
            {Key: requestIDKey, Name: "request_id"},
        },
        // Only low cardinality for metrics
        Metrics: []aperture.ContextKey{
            {Key: regionKey, Name: "region"},
            {Key: tierKey, Name: "tier"},
        },
    },
}
```

## Middleware Pattern

Common pattern: middleware adds context values that propagate through request handling:

```go
func RequestContextMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        ctx := r.Context()

        // Add request ID
        requestID := r.Header.Get("X-Request-ID")
        if requestID == "" {
            requestID = uuid.New().String()
        }
        ctx = context.WithValue(ctx, requestIDKey, requestID)

        // Add user from auth
        if userID := getUserFromAuth(r); userID != "" {
            ctx = context.WithValue(ctx, userIDKey, userID)
        }

        // Add region from header or default
        region := r.Header.Get("X-Region")
        if region == "" {
            region = "us-east-1"
        }
        ctx = context.WithValue(ctx, regionKey, region)

        next.ServeHTTP(w, r.WithContext(ctx))
    })
}
```

All events emitted during request handling automatically include these values.

## Combining with Event Fields

Context extraction complements event fields:

```go
// Context: request-scoped values
ctx = context.WithValue(ctx, userIDKey, "user-123")
ctx = context.WithValue(ctx, regionKey, "us-east-1")

// Fields: event-specific values
cap.Emit(ctx, orderCreated,
    orderID.Field("ORD-456"),
    total.Field(99.99),
)

// Log includes all:
// user_id="user-123" (from context)
// region="us-east-1" (from context)
// order_id="ORD-456" (from field)
// total=99.99 (from field)
```

## Schema Configuration

Via YAML:

```yaml
context:
  logs:
    - user_id
    - request_id
  metrics:
    - region
    - tier
  traces:
    - user_id
    - region
```

Register context keys in the registry:

```go
registry := aperture.NewRegistry()
registry.RegisterContextKey("user_id", userIDKey)
registry.RegisterContextKey("request_id", requestIDKey)
registry.RegisterContextKey("region", regionKey)
registry.RegisterContextKey("tier", tierKey)

configBytes, _ := os.ReadFile("config.yaml")
schema, _ := aperture.LoadSchemaFromYAML(configBytes)
config, _ := registry.Build(schema)
```
