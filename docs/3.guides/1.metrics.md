---
title: Metrics
description: Configure signal-to-metric transformations
author: zoobzio
published: 2025-12-11
updated: 2025-12-11
tags:
  - Guide
  - Metrics
---

# Metrics Guide

Transform capitan signals into OTEL metrics.

## Metric Types

### Counter

Increments on each signal emission. No value extraction needed.

```go
orderCreated := capitan.NewSignal("order.created", "Order created")

config := &aperture.Config{
    Metrics: []aperture.MetricConfig{
        {
            Signal:      orderCreated,
            Name:        "orders_created_total",
            Type:        aperture.MetricTypeCounter,
            Description: "Total number of orders created",
        },
    },
}

// Each emission increments by 1
cap.Emit(ctx, orderCreated)  // orders_created_total += 1
cap.Emit(ctx, orderCreated)  // orders_created_total += 1
```

### Gauge

Records the current value from a field. Useful for instantaneous measurements.

```go
cpuUsage := capitan.NewSignal("system.cpu", "CPU measurement")
percentKey := capitan.NewFloat64Key("percent")

config := &aperture.Config{
    Metrics: []aperture.MetricConfig{
        {
            Signal:   cpuUsage,
            Name:     "cpu_usage_percent",
            Type:     aperture.MetricTypeGauge,
            ValueKey: percentKey,
        },
    },
}

// Records the value from the percent field
cap.Emit(ctx, cpuUsage, percentKey.Field(45.2))  // cpu_usage_percent = 45.2
cap.Emit(ctx, cpuUsage, percentKey.Field(67.8))  // cpu_usage_percent = 67.8
```

### Histogram

Records value distributions. Ideal for latencies, sizes, or any value you want percentiles for.

```go
requestDone := capitan.NewSignal("request.done", "Request completed")
durationKey := capitan.NewDurationKey("duration")

config := &aperture.Config{
    Metrics: []aperture.MetricConfig{
        {
            Signal:   requestDone,
            Name:     "request_duration_ms",
            Type:     aperture.MetricTypeHistogram,
            ValueKey: durationKey,
        },
    },
}

// Records duration values in the distribution
cap.Emit(ctx, requestDone, durationKey.Field(10*time.Millisecond))
cap.Emit(ctx, requestDone, durationKey.Field(250*time.Millisecond))
cap.Emit(ctx, requestDone, durationKey.Field(50*time.Millisecond))
```

### UpDownCounter

Bidirectional counter for values that increase and decrease.

```go
queueChanged := capitan.NewSignal("queue.changed", "Queue size changed")
deltaKey := capitan.NewInt64Key("delta")

config := &aperture.Config{
    Metrics: []aperture.MetricConfig{
        {
            Signal:   queueChanged,
            Name:     "queue_depth",
            Type:     aperture.MetricTypeUpDownCounter,
            ValueKey: deltaKey,
        },
    },
}

// Track queue depth changes
cap.Emit(ctx, queueChanged, deltaKey.Field(int64(5)))   // queue_depth += 5
cap.Emit(ctx, queueChanged, deltaKey.Field(int64(-2)))  // queue_depth -= 2
```

## Dimensions (Attributes)

Event fields automatically become metric dimensions:

```go
orderCreated := capitan.NewSignal("order.created", "Order created")
regionKey := capitan.NewStringKey("region")
tierKey := capitan.NewStringKey("tier")

config := &aperture.Config{
    Metrics: []aperture.MetricConfig{
        {Signal: orderCreated, Name: "orders_total", Type: aperture.MetricTypeCounter},
    },
}

// Metrics include region and tier as dimensions
cap.Emit(ctx, orderCreated, regionKey.Field("us-east"), tierKey.Field("premium"))
cap.Emit(ctx, orderCreated, regionKey.Field("eu-west"), tierKey.Field("standard"))
```

Produces:
```
orders_total{region="us-east", tier="premium"} = 1
orders_total{region="eu-west", tier="standard"} = 1
```

## Cardinality Warning

High-cardinality dimensions exponentially increase storage:

```go
// GOOD: Low cardinality
regionKey := capitan.NewStringKey("region")      // ~10 values
tierKey := capitan.NewStringKey("tier")          // ~3 values

// BAD: High cardinality
userIDKey := capitan.NewStringKey("user_id")     // ~millions of values
requestIDKey := capitan.NewStringKey("request_id") // ~infinite values
```

Use context extraction carefully for metrics:

```go
config := &aperture.Config{
    ContextExtraction: &aperture.ContextExtractionConfig{
        Metrics: []aperture.ContextKey{
            {Key: regionKey, Name: "region"},    // OK
            // {Key: userIDKey, Name: "user_id"}, // Avoid
        },
    },
}
```

## Value Key Types

For gauges, histograms, and up-down counters, the `ValueKey` extracts the numeric value:

| Key Type | Metric Value |
|----------|--------------|
| `Int64Key` | Int64 value |
| `Float64Key` | Float64 value |
| `DurationKey` | Float64 milliseconds |
| `IntKey` | Int64 (converted) |
| `UintKey` | Int64 (converted) |

```go
// Duration key extracts milliseconds
durationKey := capitan.NewDurationKey("duration")

// 100ms becomes 100.0
cap.Emit(ctx, sig, durationKey.Field(100*time.Millisecond))
```

## Multiple Metrics per Signal

One signal can trigger multiple metrics:

```go
requestDone := capitan.NewSignal("request.done", "Request completed")
durationKey := capitan.NewDurationKey("duration")

config := &aperture.Config{
    Metrics: []aperture.MetricConfig{
        // Count total requests
        {
            Signal: requestDone,
            Name:   "requests_total",
            Type:   aperture.MetricTypeCounter,
        },
        // Record latency distribution
        {
            Signal:   requestDone,
            Name:     "request_duration_ms",
            Type:     aperture.MetricTypeHistogram,
            ValueKey: durationKey,
        },
    },
}

// Both metrics updated
cap.Emit(ctx, requestDone, durationKey.Field(50*time.Millisecond))
```

## Missing Values

If a gauge/histogram/updowncounter emission lacks the value key:
- Metric operation is skipped for that emission
- No error (best-effort approach)

```go
config := &aperture.Config{
    Metrics: []aperture.MetricConfig{
        {Signal: sig, Name: "gauge", Type: aperture.MetricTypeGauge, ValueKey: valueKey},
    },
}

cap.Emit(ctx, sig)  // No valueKey field - gauge update skipped
cap.Emit(ctx, sig, valueKey.Field(42.0))  // gauge = 42.0
```

## Schema Configuration

Via YAML:

```yaml
metrics:
  - signal: OrderCreated
    name: orders_total
    type: counter
    description: Total orders placed

  - signal: RequestDone
    name: request_duration_ms
    type: histogram
    value_key: duration

  - signal: QueueChanged
    name: queue_depth
    type: updowncounter
    value_key: delta
```

Load with registry:

```go
registry := aperture.NewRegistry()
registry.Register(OrderCreated, RequestDone, QueueChanged)
registry.RegisterKey(duration, delta)

configBytes, _ := os.ReadFile("config.yaml")
schema, _ := aperture.LoadSchemaFromYAML(configBytes)
config, _ := registry.Build(schema)
```
