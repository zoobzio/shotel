---
title: Schema Configuration
description: File-based configuration with hot-reload support
author: zoobzio
published: 2025-12-11
updated: 2025-12-11
tags:
  - Guide
  - Schema
  - Configuration
---

# Schema Configuration Guide

Load aperture configuration from YAML or JSON files for runtime flexibility.

## Why Schema-Based Config

- **Separation**: Configuration in files, types in code
- **Hot-reload**: Update behavior without redeployment
- **Validation**: Catch errors at load time
- **Tooling**: Generate documentation from schemas

## Loading Schemas

```go
// From file
configBytes, err := os.ReadFile("observability.yaml")
if err != nil {
    log.Fatal(err)
}
schema, err := aperture.LoadSchemaFromYAML(configBytes)
if err != nil {
    log.Fatal(err)
}

// Or from JSON bytes
schema, err := aperture.LoadSchemaFromJSON(jsonData)
```

### Validation

```go
if err := schema.Validate(); err != nil {
    log.Fatalf("invalid schema: %v", err)
}
```

## Schema Format

### YAML Example

```yaml
# observability.yaml

metrics:
  - signal: OrderCreated
    name: orders_total
    type: counter
    description: Total orders placed

  - signal: RequestDone
    name: request_duration_ms
    type: histogram
    value_key: duration

  - signal: QueueChanged
    name: queue_depth
    type: updowncounter
    value_key: delta

traces:
  - start: RequestStarted
    end: RequestDone
    correlation_key: request_id
    span_name: http-request
    span_timeout: 5m

logs:
  whitelist:
    - OrderCreated
    - OrderFailed
    - RequestDone

context:
  logs:
    - user_id
    - request_id
  metrics:
    - region
  traces:
    - user_id
    - region

stdout: false
```

### JSON Example

```json
{
  "metrics": [
    {
      "signal": "OrderCreated",
      "name": "orders_total",
      "type": "counter"
    }
  ],
  "traces": [
    {
      "start": "RequestStarted",
      "end": "RequestDone",
      "correlation_key": "request_id",
      "span_name": "http-request"
    }
  ],
  "logs": {
    "whitelist": ["OrderCreated", "OrderFailed"]
  }
}
```

## Registry

The registry maps string names in schemas to actual capitan types.

### Registering Signals

```go
registry := aperture.NewRegistry()

// Register by signal (uses signal name)
registry.Register(OrderCreated, OrderFailed, RequestStarted, RequestDone)
```

### Registering Keys

```go
// Register field keys
registry.RegisterKey(orderID, duration, delta, requestID)
```

### Registering Context Keys

```go
type ctxKey string
const (
    userIDKey  ctxKey = "user_id"
    regionKey  ctxKey = "region"
    requestKey ctxKey = "request_id"
)

registry.RegisterContextKey("user_id", userIDKey)
registry.RegisterContextKey("region", regionKey)
registry.RegisterContextKey("request_id", requestKey)
```

### Registering Transformers

```go
registry.RegisterTransformer(orderVariant, aperture.MakeTransformer(
    func(key string, order OrderInfo) []log.KeyValue {
        return []log.KeyValue{
            log.String(key+".id", order.ID),
            log.Float64(key+".total", order.Total),
        }
    },
))
```

## Building Config

Convert schema to runtime config:

```go
configBytes, _ := os.ReadFile("config.yaml")
schema, _ := aperture.LoadSchemaFromYAML(configBytes)

if err := schema.Validate(); err != nil {
    log.Fatal(err)
}

config, err := registry.Build(schema)
if err != nil {
    log.Fatal(err)  // e.g., "unknown signal: UnknownEvent"
}

ap, _ := aperture.New(cap, logProvider, meterProvider, traceProvider, config)
```

## Introspection

Export registered components for tooling:

```go
spec := registry.Spec()

// Available signals
for _, sig := range spec.Signals {
    fmt.Printf("Signal: %s - %s\n", sig.Name, sig.Description)
}

// Available keys
for _, key := range spec.Keys {
    fmt.Printf("Key: %s (variant: %s)\n", key.Name, key.Variant)
}

// Available context keys
for _, name := range spec.ContextKeys {
    fmt.Printf("Context key: %s\n", name)
}
```

Useful for:
- Generating schema documentation
- Validating schemas against registered types
- IDE/tooling integration

## Hot-Reload with Flux

Integrate with [flux](https://github.com/zoobzio/flux) for live configuration updates:

```go
registry := aperture.NewRegistry()
registry.Register(OrderCreated, OrderFailed, RequestStarted, RequestDone)
registry.RegisterKey(orderID, duration, requestID)

var (
    currentAperture *aperture.Aperture
    mu              sync.Mutex
)

capacitor := flux.New[aperture.Schema](
    flux.FileWatcher("observability.yaml"),
    func(schema aperture.Schema) error {
        // Validate first
        if err := schema.Validate(); err != nil {
            return err
        }

        // Build config
        config, err := registry.Build(schema)
        if err != nil {
            return err
        }

        mu.Lock()
        defer mu.Unlock()

        // Close old aperture
        if currentAperture != nil {
            currentAperture.Close()
        }

        // Create new aperture with new config
        currentAperture, err = aperture.New(cap, logProvider, meterProvider, traceProvider, config)
        return err
    },
)

capacitor.Start(ctx)
```

Changes to `observability.yaml` are applied live without restart.

## Schema Reference

### Metrics

| Field | Required | Description |
|-------|----------|-------------|
| `signal` | Yes | Signal name (must be registered) |
| `name` | Yes | OTEL metric name |
| `type` | No | `counter` (default), `gauge`, `histogram`, `updowncounter` |
| `value_key` | For non-counters | Field key name for numeric value |
| `description` | No | Metric description |

### Traces

| Field | Required | Description |
|-------|----------|-------------|
| `start` | Yes | Signal that begins the span |
| `end` | Yes | Signal that completes the span |
| `correlation_key` | Yes | Field key name to match start/end |
| `span_name` | No | Span name (defaults to start signal name) |
| `span_timeout` | No | Max wait for end event (default: 5m) |

### Logs

| Field | Description |
|-------|-------------|
| `whitelist` | Signal names to log (empty = log all) |

### Context

| Field | Description |
|-------|-------------|
| `logs` | Context key names for log attributes |
| `metrics` | Context key names for metric dimensions |
| `traces` | Context key names for span attributes |

### Root Options

| Field | Description |
|-------|-------------|
| `stdout` | Enable stdout logging (boolean) |

## Error Handling

Schema build errors are explicit:

```go
config, err := registry.Build(schema)
// Possible errors:
// - "unknown signal: FooEvent"
// - "unknown key: bar_field"
// - "unknown context key: unknown_ctx"
// - "metric 'orders_total' references unknown value_key: missing"
```

Validation catches structural issues:

```go
err := schema.Validate()
// Possible errors:
// - "metric config missing signal"
// - "metric config missing name"
// - "trace config missing correlation_key"
```
